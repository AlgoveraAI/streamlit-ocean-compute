{"version":3,"sources":["OceanCompute.tsx","index.tsx"],"names":["web3","Web3","window","ethereum","datatoken","Datatoken","tokenPriceQuery","gql","getTestConfig","ConfigHelper","eth","getChainId","config","getConfig","providerUri","process","PROVIDER_URL","fetchData","query","variables","context","console","log","url","client","createClient","toPromise","response","LoggerInstance","error","message","getQueryContext","chainId","subgraphUri","queryContext","requestPolicy","getFixedBuyPrice","accessDetails","fixed","FixedRateExchange","fixedRateExchangeAddress","calcBaseInGivenOutDT","addressOrId","NEXT_PUBLIC_CONSUME_MARKET_FIXED_SWAP_FEE","estimatedPrice","getAccessDetailsFromTokenPrice","tokenPrice","timeout","dispensers","length","fixedRateExchanges","type","orders","order","reusedOrder","reuses","isOwned","Date","now","createdTimestamp","validOrderTx","tx","publisherMarketOrderFee","publishMarketFeeAmount","dispenser","token","id","price","isPurchasable","active","address","name","symbol","exchangeId","baseToken","decimals","getOrderPriceAndFees","asset","accountId","providerFees","orderPriceAndFee","NEXT_PUBLIC_PUBLISHER_MARKET_ORDER_FEE","publisherMarketFixedSwapFee","consumeMarketOrderFee","NEXT_PUBLIC_CONSUME_MARKET_ORDER_FEE","consumeMarketFixedSwapFee","providerFee","providerFeeAmount","opcFee","ProviderInstance","initialize","services","serviceEndpoint","initializeData","baseTokenAmount","oceanFeeAmount","marketFeeAmount","consumeMarketFeeAmount","Decimal","add","toString","getAccessDetails","datatokenAddress","account","Number","datatokenId","toLowerCase","tokenQueryResult","data","handleOrder","ddo","payerAccount","consumerAccount","serviceIndex","consumeMarkerFee","approveProviderFee","approveWei","providerFeeToken","validOrder","reuseOrder","transactionHash","balance","tokenBalance","startOrder","buyAndOrder","Error","orderParams","consumer","_providerFee","_consumeMarketFee","consumeMarketFeeAddress","providerFeeAddress","consumeMarketFeeToken","undefined","orderPriceAndFees","amountToUnits","approve","freParams","exchangeContract","maxBaseTokenAmount","baseTokenAddress","baseTokenDecimals","swapMarketFee","marketFeeAddress","buyFromFreAndOrder","dispenserAddress","buyFromDispenserAndOrder","runCompute","dataDid","algoDid","userAddress","request","method","accounts","providerUrl","getComputeEnvironments","computeEnvs","computeEnv","find","ce","priceMin","aquarius","Aquarius","metadataCacheUri","waitForAqua","resolvedDdoWith1mTimeout","resolvedAlgoDdoWith1mTimeout","assets","documentId","serviceId","dtAddressArray","algo","mytime","setMinutes","getMinutes","computeValidUntil","Math","floor","getTime","initializeCompute","providerInitializeComputeResults","algorithm","consumerAddress","transferTxId","datasets","i","publishAlgorithmLog","publishOutput","computeStart","computeJobs","freeEnvDatasetTxId","freeEnvAlgoTxId","computeJobId","jobId","getComputeStatus","computeStatus","jobStatus","statusText","getResults","getComputeResultUrl","downloadURL","RunCompute","state","computeResults","isFocused","render","theme","props","style","borderStyling","primaryColor","border","outline","backgroundColor","args","color","borderRadius","onClick","onClicked","disabled","onFocus","_onFocus","onBlur","_onBlur","transaction","setState","Streamlit","setComponentValue","status","results","StreamlitComponentBase","withStreamlitConnection","ReactDOM","StrictMode","OceanCompute","document","getElementById"],"mappings":"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","file":"static/js/main.ae8871da.chunk.js","sourcesContent":["\n\nimport {\n    Streamlit,\n    StreamlitComponentBase,\n    withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\nimport { Decimal } from 'decimal.js'\nimport { Client, gql, OperationContext, OperationResult, TypedDocumentNode, createClient } from \"urql\"\nimport Web3  from \"web3\"\n\nimport {\n  amountToUnits,\n  approveWei,\n  Aquarius,\n  Asset,\n  balance,\n  ComputeOutput,\n  ConfigHelper,\n  ConsumeMarketFee,\n  Datatoken,\n  FixedRateExchange,\n  FreOrderParams,\n  LoggerInstance,\n  OrderParams,\n  ProviderComputeInitialize,\n  ProviderFees,\n  ProviderInstance,\n } from \"@oceanprotocol/lib\"\n\ninterface State {\n    computeJobId: any\n    computeStatus: any\n    computeResults: any\n    isFocused: boolean\n}\n  \ndeclare global {\n    interface Window {\n      ethereum: any;\n    }\n}\n\ndeclare global {\n  interface AssetExtended extends Asset {\n    accessDetails?: any\n  }\n}\n\n\n// default variables used throughout the script\nconst web3 = new Web3(window.ethereum)\nconst datatoken = new Datatoken(web3)\n\nconst tokenPriceQuery = gql`\n  query TokenPriceQuery($datatokenId: ID!, $account: String) {\n    token(id: $datatokenId) {\n      id\n      symbol\n      name\n      publishMarketFeeAddress\n      publishMarketFeeToken\n      publishMarketFeeAmount\n      orders(\n        where: { payer: $account }\n        orderBy: createdTimestamp\n        orderDirection: desc\n      ) {\n        tx\n        serviceIndex\n        createdTimestamp\n        reuses(orderBy: createdTimestamp, orderDirection: desc) {\n          id\n          caller\n          createdTimestamp\n          tx\n          block\n        }\n      }\n      dispensers {\n        id\n        active\n        isMinter\n        maxBalance\n        token {\n          id\n          name\n          symbol\n        }\n      }\n      fixedRateExchanges {\n        id\n        exchangeId\n        price\n        publishMarketSwapFee\n        baseToken {\n          symbol\n          name\n          address\n          decimals\n        }\n        datatoken {\n          symbol\n          name\n          address\n        }\n        active\n      }\n    }\n  }\n`\n\n\n/**\n   * @interface AccessDetails\n   * @prop {'fixed' | 'free' | 'NOT_SUPPORTED'}  type\n   * @prop {string} price can be either spotPrice/rate\n   * @prop {string} addressOrId for fixed/free this is an id.\n   * @prop {TokenInfo} baseToken\n   * @prop {TokenInfo} datatoken\n   * @prop {bool} isPurchasable checks if you can buy a datatoken from fixed rate exchange/dispenser.\n   * @prop {bool} isOwned checks if there are valid orders for this, it also takes in consideration timeout\n   * @prop {string} validOrderTx  the latest valid order tx, it also takes in consideration timeout\n   * @prop {string} publisherMarketOrderFee this is here just because it's more efficient, it's allready in the query\n   * @prop {FeeInfo} feeInfo  values of the relevant fees\n   */\n interface AccessDetails {\n  type: 'fixed' | 'free' | 'NOT_SUPPORTED'\n  price: string\n  addressOrId: string\n  baseToken: any\n  datatoken: any\n  isPurchasable?: boolean\n  isOwned: boolean\n  validOrderTx: string\n  publisherMarketOrderFee: string\n}\n\n/**\n   * @interface OrderPriceAndFee\n   * @prop {string}  price total price including fees\n   * @prop {string}  publisherMarketOrderFee fee received by the market where the asset was published. It is set on erc20 creation. It is a absolute value\n   * @prop {string}  publisherMarketFixedSwapFee fee received by the market where the asset was published on any swap (fre). Absolute value based on the configured percentage\n   * @prop {string}  consumeMarketOrderFee fee received by the market where the asset is ordered. It is set on erc20 creation. It is a absolute value\n   * @prop {string}  consumeMarketFixedSwapFee fee received by the market where the asset is ordered on any swap (fre). Absolute value based on the configured percentage\n   * @prop {ProviderFees} providerFee received from provider\n   * @prop {string}  opcFee ocean protocol community fee, Absolute value based on the configured percentage\n   */\n interface OrderPriceAndFees {\n  price: string\n  publisherMarketOrderFee: string\n  publisherMarketFixedSwapFee: string\n  consumeMarketOrderFee: string\n  consumeMarketFixedSwapFee: string\n  providerFee: ProviderFees\n  opcFee: string\n}\n\n// helper functions\nconst getTestConfig = async (web3: Web3) => {\n  const config = new ConfigHelper().getConfig(await web3.eth.getChainId())\n  config.providerUri = process.env.PROVIDER_URL || config.providerUri\n  return config\n}\nlet urqlClient: Client\n\nfunction getUrqlClientInstance(): Client {\n  return urqlClient\n}\n\n\nasync function fetchData(\n  query: TypedDocumentNode,\n  variables: any,\n  context: OperationContext\n): Promise<any> {\n  try {\n    console.log(\"Fetching data, query is \", query)\n    // const client = getUrqlClientInstance()\n    console.log(\"Context url is \", context.url)\n    const client = createClient({ url: context.url })\n    console.log(\"Intialized client is \", client)\n\n    const response = await client.query(query, variables, context).toPromise()\n    console.log(\"Response is \", response)\n    return response\n  } catch (error: any) {\n    LoggerInstance.error('Error fetchData: ', error.message)\n  }\n  return null\n}\n\nasync function getQueryContext(chainId: number) {\n  try {\n    const config: any = await getTestConfig(web3)\n    const subgraphUri = config.subgraphUri\n    const queryContext: OperationContext = {\n      url: `${subgraphUri}/subgraphs/name/oceanprotocol/ocean-subgraph`,\n      requestPolicy: 'network-only'\n    }\n    console.log(\"Query context is \", queryContext)\n    return queryContext\n  } catch (error: any) {\n    LoggerInstance.error('Get query context error: ', error.message)\n  }\n}\n\nasync function getFixedBuyPrice(accessDetails: any, chainId: any) {\n  let config: any = await getTestConfig(web3)\n  const fixed: any = new FixedRateExchange(config.fixedRateExchangeAddress, web3)\n  const estimatedPrice = await fixed.calcBaseInGivenOutDT(\n    accessDetails.addressOrId,\n    '1',\n    process.env.NEXT_PUBLIC_CONSUME_MARKET_FIXED_SWAP_FEE || '0'\n  )\n  return estimatedPrice\n}\n\nfunction getAccessDetailsFromTokenPrice(\n  tokenPrice: any,\n  timeout?: any\n): AccessDetails {\n  const accessDetails = {} as AccessDetails\n\n  // Return early when no supported pricing schema found.\n  if (\n    tokenPrice?.dispensers?.length === 0 &&\n    tokenPrice?.fixedRateExchanges?.length === 0\n  ) {\n    accessDetails.type = 'free' // 'NOT_SUPPORTED'\n    console.log('No supported pricing schema found.')\n    return accessDetails\n  }\n\n  if (tokenPrice?.orders?.length > 0) {\n    const order = tokenPrice.orders[0]\n    const reusedOrder = order?.reuses?.length > 0 ? order.reuses[0] : null\n    // asset is owned if there is an order and asset has timeout 0 (forever) or if the condition is valid\n    accessDetails.isOwned =\n      timeout === 0 || Date.now() / 1000 - order?.createdTimestamp < timeout\n    // the last valid order should be the last reuse order tx id if there is one\n    accessDetails.validOrderTx = reusedOrder?.tx || order?.tx\n  }\n\n  // TODO: fetch order fee from sub query\n  accessDetails.publisherMarketOrderFee = tokenPrice?.publishMarketFeeAmount\n\n  // free is always the best price\n  if (tokenPrice?.dispensers?.length > 0) {\n    const dispenser = tokenPrice.dispensers[0]\n    accessDetails.type = 'free'\n    accessDetails.addressOrId = dispenser.token.id\n    accessDetails.price = '0'\n    accessDetails.isPurchasable = dispenser.active\n    accessDetails.datatoken = {\n      address: dispenser.token.id,\n      name: dispenser.token.name,\n      symbol: dispenser.token.symbol\n    }\n  }\n\n  // checking for fixed price\n  if (tokenPrice?.fixedRateExchanges?.length > 0) {\n    const fixed = tokenPrice.fixedRateExchanges[0]\n    accessDetails.type = 'fixed'\n    accessDetails.addressOrId = fixed.exchangeId\n    accessDetails.price = fixed.price\n    // in theory we should check dt balance here, we can skip this because in the market we always create fre with minting capabilities.\n    accessDetails.isPurchasable = fixed.active\n    accessDetails.baseToken = {\n      address: fixed.baseToken.address,\n      name: fixed.baseToken.name,\n      symbol: fixed.baseToken.symbol,\n      decimals: fixed.baseToken.decimals\n    }\n    accessDetails.datatoken = {\n      address: fixed.datatoken.address,\n      name: fixed.datatoken.name,\n      symbol: fixed.datatoken.symbol\n    }\n  }\n\n  return accessDetails\n}\n\n\n/**\n * This will be used to get price including fees before ordering\n * @param {AssetExtended} asset\n * @return {Promise<OrdePriceAndFee>}\n */\nexport async function getOrderPriceAndFees(\n  asset: AssetExtended,\n  accountId: any, // previously accountId?\n  providerFees?: ProviderFees\n): Promise<OrderPriceAndFees> {\n  const orderPriceAndFee = {\n    price: '0',\n    publisherMarketOrderFee: process.env.NEXT_PUBLIC_PUBLISHER_MARKET_ORDER_FEE || '0',\n    publisherMarketFixedSwapFee: '0',\n    consumeMarketOrderFee: process.env.NEXT_PUBLIC_CONSUME_MARKET_ORDER_FEE || '0',\n    consumeMarketFixedSwapFee: '0',\n    providerFee: {\n      providerFeeAmount: '0'\n    },\n    opcFee: '0'\n  } as OrderPriceAndFees\n\n  // fetch provider fee\n  const initializeData: any =\n    !providerFees &&\n    (await ProviderInstance.initialize(\n      asset?.id,\n      asset?.services[0].id,\n      0,\n      accountId,\n      asset?.services[0].serviceEndpoint\n    ))\n  orderPriceAndFee.providerFee = providerFees || initializeData.providerFee\n\n  // fetch price and swap fees\n  if (asset?.accessDetails?.type === 'fixed') {\n    const fixed = await getFixedBuyPrice(asset?.accessDetails, asset?.chainId)\n    orderPriceAndFee.price = fixed.baseTokenAmount\n    orderPriceAndFee.opcFee = fixed.oceanFeeAmount\n    orderPriceAndFee.publisherMarketFixedSwapFee = fixed.marketFeeAmount\n    orderPriceAndFee.consumeMarketFixedSwapFee = fixed.consumeMarketFeeAmount\n  }\n\n  // calculate full price, we assume that all the values are in ocean, otherwise this will be incorrect\n  orderPriceAndFee.price = new Decimal(+orderPriceAndFee.price || 0)\n    .add(new Decimal(+orderPriceAndFee?.consumeMarketOrderFee || 0))\n    .add(new Decimal(+orderPriceAndFee?.publisherMarketOrderFee || 0))\n    .toString()\n\n  return orderPriceAndFee\n}\n\n/**\n * @param {number} chainId\n * @param {string} datatokenAddress\n * @param {number} timeout timout of the service, this is needed to return order details\n * @param {string} account account that wants to buy, is needed to return order details\n * @returns {Promise<AccessDetails>}\n */\nexport async function getAccessDetails(\n  chainId: number,\n  datatokenAddress: string,\n  timeout?: number,\n  account = ''\n): Promise<any> {\n  try {\n    console.log(\"Getting AccessDetails\")\n    const queryContext: any = await getQueryContext(Number(chainId))\n    const tokenQueryResult: OperationResult<\n      any,\n      { datatokenId: string; account: string }\n    > = await fetchData(\n      tokenPriceQuery,\n      {\n        datatokenId: datatokenAddress.toLowerCase(),\n        account: account?.toLowerCase()\n      },\n      queryContext\n    )\n\n    const tokenPrice: any = tokenQueryResult.data.token\n    const accessDetails = getAccessDetailsFromTokenPrice(tokenPrice, timeout)\n    return accessDetails\n  } catch (error: any) { // previously without \"\": any\"\n    LoggerInstance.error('Error getting access details: ', error.message)\n  }\n}\n\n\n\n\n// core functions for interacting with the Ocean Market\nasync function handleOrder(\n  ddo: Asset & { accessDetails?: AccessDetails },\n  order: any,\n  datatokenAddress: string,\n  payerAccount: string,\n  consumerAccount: string,\n  serviceIndex: number,\n  consumeMarkerFee?: ConsumeMarketFee\n) {\n  console.log(\"order provider fee\", order.providerFee)\n  /* We do have 3 possible situations:\n     - have validOrder and no providerFees -> then order is valid, providerFees are valid, just use it in startCompute\n     - have validOrder and providerFees -> then order is valid but providerFees are not valid, we need to call reuseOrder and pay only providerFees\n     - no validOrder -> we need to call startOrder, to pay 1 DT & providerFees\n  */\n    const approveProviderFee = async () => {\n      console.log(\"Approving provider fee\")\n      console.log(\"provider fee\", order.providerFee)\n      // Approve provider fees if exists\n      // if (order.providerFee && order.providerFee.providerFeeAmount) {\n        // await datatoken.approve(\n        //   order.providerFee.providerFeeToken,\n        //   datatokenAddress,\n        //   order.providerFee.providerFeeAmount,\n        //   payerAccount\n        // );\n        const config = await getTestConfig(web3)\n        await approveWei(\n          web3,\n          config,\n          payerAccount,\n          order.providerFee.providerFeeToken,\n          datatokenAddress,\n          order.providerFee.providerFeeAmount,\n          // datatokenAddress,\n        )\n      // }\n    };\n\n    // Return if order already valid, pay fees if neccessary\n    if (order.validOrder) {\n      console.log(\"Order is already valid.\");\n      if (!order.providerFee) return order.validOrder;\n\n      await approveProviderFee();\n\n      const tx = await datatoken.reuseOrder(\n        datatokenAddress,\n        payerAccount,\n        order.validOrder,\n        order.providerFee // Must be defined because of first IF check\n      );\n      return tx.transactionHash;\n    }\n  \n    // Check if user already owns the tokens\n    const tokenBalance = await balance(web3, datatokenAddress, payerAccount);\n    console.log(\"Datatoken balance\", tokenBalance);\n\n  if (Number(tokenBalance) >= 1) {\n    console.log(\"User already owns the tokens, approving provider fee and starting order\");\n    await approveProviderFee();\n    const tx = await datatoken.startOrder(\n      datatokenAddress,\n      payerAccount,\n      consumerAccount,\n      serviceIndex,\n      order.providerFee,\n      consumeMarkerFee\n    )\n    console.log(\"Service index when user already owns tokens: \", serviceIndex)\n    return tx.transactionHash\n  }\n  // testing logs\n  console.log(\"ddo\", ddo)\n  console.log(\"datatokenAddress\", datatokenAddress)\n  console.log(\"payerAccount\", payerAccount)\n  console.log(\"consumerAccount\", consumerAccount)\n  console.log(\"serviceIndex\", serviceIndex)\n  console.log(\"order\", order)\n  console.log(\"consumeMarkerFee\", consumeMarkerFee)\n  // end testing logs\n  return await buyAndOrder(\n    ddo,\n    order,\n    datatokenAddress,\n    payerAccount,\n    consumerAccount,\n    serviceIndex,\n    approveProviderFee,\n    consumeMarkerFee\n  );\n}\n\n// buyAndOrder datasets, algorithms, compute\nconst buyAndOrder = async (\n  ddo: Asset & { accessDetails?: AccessDetails },\n  order: ProviderComputeInitialize,\n  datatokenAddress: string,\n  payerAccount: string,\n  consumerAccount: string,\n  serviceIndex: number,\n  approveProviderFee: () => Promise<void>,\n  consumeMarkerFee?: ConsumeMarketFee\n) => {\n  if (!order.providerFee)\n    throw new Error(\"Undefined token for paying fees.\");\n  console.log(\"Service index when user does not own tokens: \", serviceIndex)\n  const orderParams: OrderParams = {\n    consumer: consumerAccount,\n    serviceIndex: serviceIndex,\n    _providerFee: order.providerFee,\n    _consumeMarketFee: { // consumeMarkerFee ??\n      consumeMarketFeeAddress: order.providerFee.providerFeeAddress, // previously \"0x0000000000000000000000000000000000000000\"\n      consumeMarketFeeToken: order.providerFee.providerFeeToken,\n      consumeMarketFeeAmount: order.providerFee.providerFeeAmount, // previously \"0\"\n    },\n  };\n  console.log(\"ddo.accessDetails\", ddo.accessDetails);\n  let accessDetails = ddo.accessDetails ?? await getAccessDetails(\n    ddo.chainId,\n    datatokenAddress,\n    3600, // TODO: valid until\n    payerAccount,\n  );\n  console.log(\"accessDetails\", accessDetails);\n  accessDetails = {}\n  accessDetails.type = 'free'\n  // temporary until subgraph works again\n  if (accessDetails === undefined ) {\n    accessDetails = {}\n    accessDetails.type = 'free'\n    // accessDetails.type = 'fixed'\n    console.log(\"got here\")\n  }\n  const config: any = await getTestConfig(web3)\n\n  switch (accessDetails?.type) {\n\n    case \"fixed\": {\n      await approveProviderFee(); // test code\n      if (!config.fixedRateExchangeAddress)\n        throw new Error(\"Undefined exchange address - unable to purchase data token.\");\n\n      const orderPriceAndFees = await getOrderPriceAndFees(ddo, accessDetails, order.providerFee);\n      console.log(\"pricing is fixed\")\n\n      // this assumes all fees are in ocean\n      await datatoken.approve(\n        order.providerFee?.providerFeeToken,\n        datatokenAddress,\n        await amountToUnits(\n          web3,\n          order.providerFee?.providerFeeToken ?? \"0\",\n          orderPriceAndFees.price,\n          18, // amountToUnits doesn't need web3 if decimals (18) are specified\n        ),\n        payerAccount\n      );\n\n      const freParams: FreOrderParams = {\n        exchangeContract: config.fixedRateExchangeAddress,\n        exchangeId: accessDetails.addressOrId,\n        maxBaseTokenAmount: orderPriceAndFees.price,\n        baseTokenAddress: order.providerFee?.providerFeeToken,\n        baseTokenDecimals: 18, // TODO: Here we assume 18 decimal token, might not be the case\n        swapMarketFee: \"0\",\n        marketFeeAddress: \"0x0000000000000000000000000000000000000000\",\n      };\n\n      const tx = await datatoken.buyFromFreAndOrder(\n        datatokenAddress,\n        payerAccount,\n        orderParams,\n        freParams\n      );\n      return tx.transactionHash;\n    }\n    case \"free\": {\n      if (!config.dispenserAddress)\n        throw new Error(\"undefined dispenser address - unable to purchase free data token.\");\n\n      // Pay provider fee for running alg\n      await approveProviderFee();\n\n      await datatoken.approve(\n        order.providerFee?.providerFeeToken,\n        datatokenAddress,\n        await amountToUnits(\n          web3,\n          order.providerFee?.providerFeeToken ?? \"0\",\n          \"0\",\n          18, // amountToUnits doesn't need web3 if decimals (18) are specified\n        ),\n        payerAccount\n      );\n\n      const tx = await datatoken.buyFromDispenserAndOrder(\n        datatokenAddress,\n        payerAccount,\n        orderParams,\n        config.dispenserAddress\n      );\n      \n      return tx.transactionHash;\n    }\n    default: {\n      throw new Error(\"Data with unsupported access type\");\n    }\n  }\n};\n\n\n// main function executed by the button\nasync function runCompute(dataDid: string, algoDid: string , userAddress: string) {\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const payerAccount = accounts[0]\n\n  const config: any = await getTestConfig(web3)\n  console.log(\"config\", config)\n  const providerUrl = config.providerUri\n\n  const computeEnvs = await ProviderInstance.getComputeEnvironments(providerUrl)\n  console.log(\"Available compute environments\", computeEnvs)\n  const computeEnv = computeEnvs.find((ce) => ce.priceMin === 0)\n  console.log(\"computeEnv\", computeEnv)\n\n  const aquarius = new Aquarius(config.metadataCacheUri)\n  console.log(\"Data DID\", dataDid)\n  console.log(\"Algo DID\", algoDid)\n  const resolvedDdoWith1mTimeout = await aquarius.waitForAqua(dataDid);\n  const resolvedAlgoDdoWith1mTimeout = await aquarius.waitForAqua(algoDid);\n  console.log(\"resolvedDataDDO\", resolvedDdoWith1mTimeout)\n  console.log(\"resolvedAlgoDDO\", resolvedAlgoDdoWith1mTimeout)\n\n  const assets: any[] = [\n    {\n      documentId: resolvedDdoWith1mTimeout.id,\n      serviceId: resolvedDdoWith1mTimeout.services[0].id\n    }\n  ]\n  console.log(\"assets\", assets)\n  const dtAddressArray = [resolvedDdoWith1mTimeout.services[0].datatokenAddress]\n  console.log(\"dtAddressArray\", dtAddressArray)\n  const algo: any = {\n    documentId: resolvedAlgoDdoWith1mTimeout.id,\n    serviceId: resolvedAlgoDdoWith1mTimeout.services[0].id\n  }\n  console.log(\"algo\", algo)\n  const mytime = new Date()\n  const computeMinutes = 20\n  console.log(\"computeMinutes\", computeMinutes)\n  mytime.setMinutes(mytime.getMinutes() + computeMinutes)\n  let computeValidUntil = Math.floor(mytime.getTime() / 1000)\n  console.log(\"computeValidUntil\", computeValidUntil)\n  if (computeEnv !== undefined) {\n  const providerInitializeComputeResults = await ProviderInstance.initializeCompute(\n    assets,\n    algo,\n    computeEnv.id,\n    computeValidUntil,\n    providerUrl,\n    payerAccount\n  )\n  console.log(\"providerInitializeComputeResults\", providerInitializeComputeResults)\n  console.log(\"Handling order for algorithm\")\n  algo.transferTxId = await handleOrder(\n    resolvedAlgoDdoWith1mTimeout,\n    providerInitializeComputeResults.algorithm,\n    resolvedAlgoDdoWith1mTimeout.services[0].datatokenAddress,\n    payerAccount,\n    computeEnv.consumerAddress,\n    0\n  )\n\n  console.log(\"algo.transferTxId\", algo.transferTxId)\n\n  if (providerInitializeComputeResults.datasets !== undefined) {\n  for (let i = 0; i < providerInitializeComputeResults.datasets.length; i++) {\n    console.log(\"Handling order for dataset\")\n    assets[i].transferTxId = await handleOrder(\n      resolvedDdoWith1mTimeout,\n      providerInitializeComputeResults.datasets[i],\n      dtAddressArray[i],\n      payerAccount,\n      computeEnv.consumerAddress,\n      0\n    )\n  }\n  console.log(\"About to start compute\")\n  console.log(\"Provider URL\", providerUrl)\n  const output: ComputeOutput = {\n    publishAlgorithmLog: true,\n    publishOutput: true\n  }\n\n  const computeJobs: any = await ProviderInstance.computeStart(\n      providerUrl,\n      web3,\n      payerAccount,\n      computeEnv.id,\n      assets[0],\n      algo,\n      // undefined,\n      // undefined,\n      // output\n  )\n\n  console.log(\"computeJobs\", computeJobs)\n\n  const freeEnvDatasetTxId = assets[0].transferTxId\n  console.log(\"freeEnvDatasetTxId\", freeEnvDatasetTxId)\n  const freeEnvAlgoTxId = algo.transferTxId\n  console.log(\"freeEnvAlgoTxId\", freeEnvAlgoTxId)\n  const computeJobId = computeJobs[0].jobId\n\n  console.log(\"computeJobId\", computeJobId)\n  return [computeJobId, resolvedDdoWith1mTimeout]\n  }\n\n  }\n\n}\n\nasync function getComputeStatus(computeJobId: any, dataDid: any) {\n  const config: any = await getTestConfig(web3)\n  const aquarius = new Aquarius(config.metadataCacheUri)\n  // const resolvedDdoWith1mTimeout = await aquarius.waitForAqua(dataDid);\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const consumerAccount = accounts[0]\n  const providerUrl = config.providerUri\n  const jobStatus: any = await ProviderInstance.computeStatus(\n    providerUrl,\n    consumerAccount,\n    computeJobId,\n    dataDid// DATASET_DDO.id\n  )\n  // assert(jobStatus, 'Cannot retrieve compute status!')\n  console.log(jobStatus)\n  return jobStatus[0].statusText\n}\n\nasync function getResults(computeJobId: any) {\n  console.log(\"Getting results\")\n  const config: any = await getTestConfig(web3)\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const consumerAccount = accounts[0]\n  const providerUrl = config.providerUri\n  const downloadURL = await ProviderInstance.getComputeResultUrl(\n    providerUrl,\n    web3,\n    consumerAccount,\n    computeJobId,\n    0\n  )\n\n  console.log(`Compute results URL: ${downloadURL}`)\n  return downloadURL\n}\n     \n  /**\n   * This is a React-based component template. The `render()` function is called\n   * automatically when your component should be re-rendered.\n   */\nclass RunCompute extends StreamlitComponentBase<State> {\n  public state = { computeJobId: \"No compute job\", computeStatus: \"No Status\", computeResults: \"No Compute Results\", isFocused: false }\n\n    public render = (): ReactNode => {\n      // Arguments that are passed to the plugin in Python are accessible\n      // via `this.props.args`. Here, we access the \"name\" arg.\n      // Streamlit sends us a theme object via props that we can use to ensure\n      // that our component has visuals that match the active theme in a\n      // streamlit app.\n      const { theme } = this.props\n      const style: React.CSSProperties = {}\n\n      // Maintain compatibility with older versions of Streamlit that don't send\n      // a theme object.\n      if (theme) {\n        // Use the theme object to style our button border. Alternatively, the\n        // theme style is defined in CSS vars.\n        const borderStyling = `0px solid ${\n          this.state.isFocused ? theme.primaryColor : \"gray\"\n        }`\n        style.border = borderStyling\n        style.outline = borderStyling\n        style.backgroundColor = this.props.args[\"color\"] //\"#FF4B4B\"\n        style.color = \"white\"\n        style.borderRadius = \"0.2rem\"\n      }\n      const message = this.props.args[\"message\"]\n      // Show a button and some text.\n      // When the button is clicked, we'll increment our \"numClicks\" state\n      // variable, and send its new value back to Streamlit, where it'll\n      // be available to the Python program.\n      return (\n        <span>\n          <button\n            style={style}\n            onClick={this.onClicked}\n            disabled={this.props.disabled}\n            onFocus={this._onFocus}\n            onBlur={this._onBlur}\n          >\n            {message}\n          </button>\n        </span>\n      )\n    }\n  \n    /** Click handler for our \"Click Me!\" button. */\n    private onClicked = async (): Promise<void> => {\n      if (this.props.args[\"key\"] === \"c2d\") {\n        const transaction: any = await runCompute(this.props.args[\"data_did\"], this.props.args[\"algo_did\"], this.props.args[\"user_address\"])\n        this.setState(\n          () => ({ computeJobId: transaction }),\n          () => Streamlit.setComponentValue(this.state.computeJobId)\n        )\n      } else if (this.props.args[\"key\"] === \"status\") {\n        const status: any = await getComputeStatus(this.props.args[\"job_id\"], this.props.args[\"data_did\"])\n        this.setState(\n            () => ({ computeStatus: status }),\n            () => Streamlit.setComponentValue(this.state.computeStatus)\n        )\n      } else if (this.props.args[\"key\"] === \"results\") {\n        const results: any = await getResults(this.props.args[\"job_id\"])\n        this.setState(\n          () => ({ computeResults: results }),\n          () => Streamlit.setComponentValue(this.state.computeResults)\n      )\n      }\n      // Increment state.numClicks, and pass the new value back to\n      // Streamlit via `Streamlit.setComponentValue`.\n    }\n  \n    /** Focus handler for our \"Click Me!\" button. */\n    private _onFocus = (): void => {\n      this.setState({ isFocused: true })\n    }\n  \n    /** Blur handler for our \"Click Me!\" button. */\n    private _onBlur = (): void => {\n      this.setState({ isFocused: false })\n    }\n  }\n  \n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(RunCompute)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\n// import OceanDataComponent from \"./OceanDataComponent\"\nimport OceanCompute from \"./OceanCompute\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <OceanCompute />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}