{"version":3,"sources":["OceanCompute.tsx","index.tsx"],"names":["web3","Web3","window","ethereum","datatoken","Datatoken","getTestConfig","gql","ConfigHelper","eth","getChainId","config","getConfig","providerUri","process","PROVIDER_URL","handleOrder","ddo","order","datatokenAddress","payerAccount","consumerAccount","serviceIndex","consumeMarkerFee","console","log","providerFee","approveProviderFee","approveWei","providerFeeToken","providerFeeAmount","validOrder","reuseOrder","tx","transactionHash","balance","tokenBalance","startOrder","runCompute","dataDid","algoDid","userAddress","request","method","accounts","providerUrl","ProviderInstance","getComputeEnvironments","computeEnvs","computeEnv","find","ce","priceMin","aquarius","Aquarius","metadataCacheUri","waitForAqua","resolvedDdoWith1mTimeout","resolvedAlgoDdoWith1mTimeout","assets","documentId","id","serviceId","services","dtAddressArray","algo","mytime","Date","setMinutes","getMinutes","computeValidUntil","Math","floor","getTime","undefined","initializeCompute","providerInitializeComputeResults","algorithm","consumerAddress","transferTxId","datasets","i","length","publishAlgorithmLog","publishOutput","computeStart","computeJobs","freeEnvDatasetTxId","freeEnvAlgoTxId","computeJobId","jobId","getComputeStatus","computeStatus","jobStatus","statusText","getResults","getComputeResultUrl","downloadURL","RunCompute","state","computeResults","isFocused","render","theme","props","style","borderStyling","primaryColor","border","outline","backgroundColor","args","color","borderRadius","message","onClick","onClicked","disabled","onFocus","_onFocus","onBlur","_onBlur","transaction","setState","Streamlit","setComponentValue","status","results","StreamlitComponentBase","withStreamlitConnection","ReactDOM","StrictMode","OceanCompute","document","getElementById"],"mappings":"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","file":"static/js/main.474992f3.chunk.js","sourcesContent":["\n\nimport {\n    Streamlit,\n    StreamlitComponentBase,\n    withStreamlitConnection,\n} from \"streamlit-component-lib\"\nimport React, { ReactNode } from \"react\"\n\nimport { Decimal } from 'decimal.js'\nimport { Client, gql, OperationContext, OperationResult, TypedDocumentNode, createClient } from \"urql\"\nimport Web3  from \"web3\"\n\nimport {\n  amountToUnits,\n  approveWei,\n  Aquarius,\n  Asset,\n  balance,\n  ComputeOutput,\n  ConfigHelper,\n  ConsumeMarketFee,\n  Datatoken,\n  FixedRateExchange,\n  FreOrderParams,\n  LoggerInstance,\n  OrderParams,\n  ProviderComputeInitialize,\n  ProviderFees,\n  ProviderInstance,\n } from \"@oceanprotocol/lib\"\n\ninterface State {\n    computeJobId: any\n    computeStatus: any\n    computeResults: any\n    isFocused: boolean\n}\n  \ndeclare global {\n    interface Window {\n      ethereum: any;\n    }\n}\n\ndeclare global {\n  interface AssetExtended extends Asset {\n    accessDetails?: any\n  }\n}\n\n\n// default variables used throughout the script\nconst web3 = new Web3(window.ethereum)\nconst datatoken = new Datatoken(web3)\n\nconst tokenPriceQuery = gql`\n  query TokenPriceQuery($datatokenId: ID!, $account: String) {\n    token(id: $datatokenId) {\n      id\n      symbol\n      name\n      publishMarketFeeAddress\n      publishMarketFeeToken\n      publishMarketFeeAmount\n      orders(\n        where: { payer: $account }\n        orderBy: createdTimestamp\n        orderDirection: desc\n      ) {\n        tx\n        serviceIndex\n        createdTimestamp\n        reuses(orderBy: createdTimestamp, orderDirection: desc) {\n          id\n          caller\n          createdTimestamp\n          tx\n          block\n        }\n      }\n      dispensers {\n        id\n        active\n        isMinter\n        maxBalance\n        token {\n          id\n          name\n          symbol\n        }\n      }\n      fixedRateExchanges {\n        id\n        exchangeId\n        price\n        publishMarketSwapFee\n        baseToken {\n          symbol\n          name\n          address\n          decimals\n        }\n        datatoken {\n          symbol\n          name\n          address\n        }\n        active\n      }\n    }\n  }\n`\n\n\n/**\n   * @interface AccessDetails\n   * @prop {'fixed' | 'free' | 'NOT_SUPPORTED'}  type\n   * @prop {string} price can be either spotPrice/rate\n   * @prop {string} addressOrId for fixed/free this is an id.\n   * @prop {TokenInfo} baseToken\n   * @prop {TokenInfo} datatoken\n   * @prop {bool} isPurchasable checks if you can buy a datatoken from fixed rate exchange/dispenser.\n   * @prop {bool} isOwned checks if there are valid orders for this, it also takes in consideration timeout\n   * @prop {string} validOrderTx  the latest valid order tx, it also takes in consideration timeout\n   * @prop {string} publisherMarketOrderFee this is here just because it's more efficient, it's allready in the query\n   * @prop {FeeInfo} feeInfo  values of the relevant fees\n   */\n interface AccessDetails {\n  type: 'fixed' | 'free' | 'NOT_SUPPORTED'\n  price: string\n  addressOrId: string\n  baseToken: any\n  datatoken: any\n  isPurchasable?: boolean\n  isOwned: boolean\n  validOrderTx: string\n  publisherMarketOrderFee: string\n}\n\n/**\n   * @interface OrderPriceAndFee\n   * @prop {string}  price total price including fees\n   * @prop {string}  publisherMarketOrderFee fee received by the market where the asset was published. It is set on erc20 creation. It is a absolute value\n   * @prop {string}  publisherMarketFixedSwapFee fee received by the market where the asset was published on any swap (fre). Absolute value based on the configured percentage\n   * @prop {string}  consumeMarketOrderFee fee received by the market where the asset is ordered. It is set on erc20 creation. It is a absolute value\n   * @prop {string}  consumeMarketFixedSwapFee fee received by the market where the asset is ordered on any swap (fre). Absolute value based on the configured percentage\n   * @prop {ProviderFees} providerFee received from provider\n   * @prop {string}  opcFee ocean protocol community fee, Absolute value based on the configured percentage\n   */\n interface OrderPriceAndFees {\n  price: string\n  publisherMarketOrderFee: string\n  publisherMarketFixedSwapFee: string\n  consumeMarketOrderFee: string\n  consumeMarketFixedSwapFee: string\n  providerFee: ProviderFees\n  opcFee: string\n}\n\n// helper functions\nconst getTestConfig = async (web3: Web3) => {\n  const config = new ConfigHelper().getConfig(await web3.eth.getChainId())\n  config.providerUri = process.env.PROVIDER_URL || config.providerUri\n  return config\n}\nlet urqlClient: Client\n\nfunction getUrqlClientInstance(): Client {\n  return urqlClient\n}\n\n\nasync function fetchData(\n  query: TypedDocumentNode,\n  variables: any,\n  context: OperationContext\n): Promise<any> {\n  try {\n    console.log(\"Fetching data, query is \", query)\n    // const client = getUrqlClientInstance()\n    console.log(\"Context url is \", context.url)\n    const client = createClient({ url: context.url })\n    console.log(\"Intialized client is \", client)\n\n    const response = await client.query(query, variables, context).toPromise()\n    console.log(\"Response is \", response)\n    return response\n  } catch (error: any) {\n    LoggerInstance.error('Error fetchData: ', error.message)\n  }\n  return null\n}\n\nasync function getQueryContext(chainId: number) {\n  try {\n    const config: any = await getTestConfig(web3)\n    const subgraphUri = config.subgraphUri\n    const queryContext: OperationContext = {\n      url: `${subgraphUri}/subgraphs/name/oceanprotocol/ocean-subgraph`,\n      requestPolicy: 'network-only'\n    }\n    console.log(\"Query context is \", queryContext)\n    return queryContext\n  } catch (error: any) {\n    LoggerInstance.error('Get query context error: ', error.message)\n  }\n}\n\nasync function getFixedBuyPrice(accessDetails: any, chainId: any) {\n  let config: any = await getTestConfig(web3)\n  const fixed: any = new FixedRateExchange(config.fixedRateExchangeAddress, web3)\n  const estimatedPrice = await fixed.calcBaseInGivenOutDT(\n    accessDetails.addressOrId,\n    '1',\n    process.env.NEXT_PUBLIC_CONSUME_MARKET_FIXED_SWAP_FEE || '0'\n  )\n  return estimatedPrice\n}\n\nfunction getAccessDetailsFromTokenPrice(\n  tokenPrice: any,\n  timeout?: any\n): AccessDetails {\n  const accessDetails = {} as AccessDetails\n\n  // Return early when no supported pricing schema found.\n  if (\n    tokenPrice?.dispensers?.length === 0 &&\n    tokenPrice?.fixedRateExchanges?.length === 0\n  ) {\n    accessDetails.type = 'free' // 'NOT_SUPPORTED'\n    console.log('No supported pricing schema found.')\n    return accessDetails\n  }\n\n  if (tokenPrice?.orders?.length > 0) {\n    const order = tokenPrice.orders[0]\n    const reusedOrder = order?.reuses?.length > 0 ? order.reuses[0] : null\n    // asset is owned if there is an order and asset has timeout 0 (forever) or if the condition is valid\n    accessDetails.isOwned =\n      timeout === 0 || Date.now() / 1000 - order?.createdTimestamp < timeout\n    // the last valid order should be the last reuse order tx id if there is one\n    accessDetails.validOrderTx = reusedOrder?.tx || order?.tx\n  }\n\n  // TODO: fetch order fee from sub query\n  accessDetails.publisherMarketOrderFee = tokenPrice?.publishMarketFeeAmount\n\n  // free is always the best price\n  if (tokenPrice?.dispensers?.length > 0) {\n    const dispenser = tokenPrice.dispensers[0]\n    accessDetails.type = 'free'\n    accessDetails.addressOrId = dispenser.token.id\n    accessDetails.price = '0'\n    accessDetails.isPurchasable = dispenser.active\n    accessDetails.datatoken = {\n      address: dispenser.token.id,\n      name: dispenser.token.name,\n      symbol: dispenser.token.symbol\n    }\n  }\n\n  // checking for fixed price\n  if (tokenPrice?.fixedRateExchanges?.length > 0) {\n    const fixed = tokenPrice.fixedRateExchanges[0]\n    accessDetails.type = 'fixed'\n    accessDetails.addressOrId = fixed.exchangeId\n    accessDetails.price = fixed.price\n    // in theory we should check dt balance here, we can skip this because in the market we always create fre with minting capabilities.\n    accessDetails.isPurchasable = fixed.active\n    accessDetails.baseToken = {\n      address: fixed.baseToken.address,\n      name: fixed.baseToken.name,\n      symbol: fixed.baseToken.symbol,\n      decimals: fixed.baseToken.decimals\n    }\n    accessDetails.datatoken = {\n      address: fixed.datatoken.address,\n      name: fixed.datatoken.name,\n      symbol: fixed.datatoken.symbol\n    }\n  }\n\n  return accessDetails\n}\n\n\n/**\n * This will be used to get price including fees before ordering\n * @param {AssetExtended} asset\n * @return {Promise<OrdePriceAndFee>}\n */\nexport async function getOrderPriceAndFees(\n  asset: AssetExtended,\n  accountId: any, // previously accountId?\n  providerFees?: ProviderFees\n): Promise<OrderPriceAndFees> {\n  const orderPriceAndFee = {\n    price: '0',\n    publisherMarketOrderFee: process.env.NEXT_PUBLIC_PUBLISHER_MARKET_ORDER_FEE || '0',\n    publisherMarketFixedSwapFee: '0',\n    consumeMarketOrderFee: process.env.NEXT_PUBLIC_CONSUME_MARKET_ORDER_FEE || '0',\n    consumeMarketFixedSwapFee: '0',\n    providerFee: {\n      providerFeeAmount: '0'\n    },\n    opcFee: '0'\n  } as OrderPriceAndFees\n\n  // fetch provider fee\n  const initializeData: any =\n    !providerFees &&\n    (await ProviderInstance.initialize(\n      asset?.id,\n      asset?.services[0].id,\n      0,\n      accountId,\n      asset?.services[0].serviceEndpoint\n    ))\n  orderPriceAndFee.providerFee = providerFees || initializeData.providerFee\n\n  // fetch price and swap fees\n  if (asset?.accessDetails?.type === 'fixed') {\n    const fixed = await getFixedBuyPrice(asset?.accessDetails, asset?.chainId)\n    orderPriceAndFee.price = fixed.baseTokenAmount\n    orderPriceAndFee.opcFee = fixed.oceanFeeAmount\n    orderPriceAndFee.publisherMarketFixedSwapFee = fixed.marketFeeAmount\n    orderPriceAndFee.consumeMarketFixedSwapFee = fixed.consumeMarketFeeAmount\n  }\n\n  // calculate full price, we assume that all the values are in ocean, otherwise this will be incorrect\n  orderPriceAndFee.price = new Decimal(+orderPriceAndFee.price || 0)\n    .add(new Decimal(+orderPriceAndFee?.consumeMarketOrderFee || 0))\n    .add(new Decimal(+orderPriceAndFee?.publisherMarketOrderFee || 0))\n    .toString()\n\n  return orderPriceAndFee\n}\n\n/**\n * @param {number} chainId\n * @param {string} datatokenAddress\n * @param {number} timeout timout of the service, this is needed to return order details\n * @param {string} account account that wants to buy, is needed to return order details\n * @returns {Promise<AccessDetails>}\n */\nexport async function getAccessDetails(\n  chainId: number,\n  datatokenAddress: string,\n  timeout?: number,\n  account = ''\n): Promise<any> {\n  try {\n    console.log(\"Getting AccessDetails\")\n    const queryContext: any = await getQueryContext(Number(chainId))\n    const tokenQueryResult: OperationResult<\n      any,\n      { datatokenId: string; account: string }\n    > = await fetchData(\n      tokenPriceQuery,\n      {\n        datatokenId: datatokenAddress.toLowerCase(),\n        account: account?.toLowerCase()\n      },\n      queryContext\n    )\n\n    const tokenPrice: any = tokenQueryResult.data.token\n    const accessDetails = getAccessDetailsFromTokenPrice(tokenPrice, timeout)\n    return accessDetails\n  } catch (error: any) { // previously without \"\": any\"\n    LoggerInstance.error('Error getting access details: ', error.message)\n  }\n}\n\n\n\n\n// core functions for interacting with the Ocean Market\nasync function handleOrder(\n  ddo: Asset & { accessDetails?: AccessDetails },\n  order: any,\n  datatokenAddress: string,\n  payerAccount: string,\n  consumerAccount: string,\n  serviceIndex: number,\n  consumeMarkerFee?: ConsumeMarketFee\n) {\n  console.log(\"order provider fee\", order.providerFee)\n  /* We do have 3 possible situations:\n     - have validOrder and no providerFees -> then order is valid, providerFees are valid, just use it in startCompute\n     - have validOrder and providerFees -> then order is valid but providerFees are not valid, we need to call reuseOrder and pay only providerFees\n     - no validOrder -> we need to call startOrder, to pay 1 DT & providerFees\n  */\n    const approveProviderFee = async () => {\n      console.log(\"Approving provider fee\")\n      console.log(\"provider fee\", order.providerFee)\n      // Approve provider fees if exists\n      // if (order.providerFee && order.providerFee.providerFeeAmount) {\n        // await datatoken.approve(\n        //   order.providerFee.providerFeeToken,\n        //   datatokenAddress,\n        //   order.providerFee.providerFeeAmount,\n        //   payerAccount\n        // );\n        const config = await getTestConfig(web3)\n        await approveWei(\n          web3,\n          config,\n          payerAccount,\n          order.providerFee.providerFeeToken,\n          datatokenAddress,\n          order.providerFee.providerFeeAmount,\n          // datatokenAddress,\n        )\n      // }\n    };\n\n    // Return if order already valid, pay fees if neccessary\n    if (order.validOrder) {\n      console.log(\"Order is already valid.\");\n      if (!order.providerFee) return order.validOrder;\n\n      await approveProviderFee();\n\n      const tx = await datatoken.reuseOrder(\n        datatokenAddress,\n        payerAccount,\n        order.validOrder,\n        order.providerFee // Must be defined because of first IF check\n      );\n      return tx.transactionHash;\n    }\n  \n    // Check if user already owns the tokens\n    const tokenBalance = await balance(web3, datatokenAddress, payerAccount);\n    console.log(\"Datatoken balance\", tokenBalance);\n\n    console.log(\"User owns the tokens, approving provider fee and starting order\");\n    await approveProviderFee();\n    const tx = await datatoken.startOrder(\n      datatokenAddress,\n      payerAccount,\n      consumerAccount,\n      serviceIndex,\n      order.providerFee,\n      consumeMarkerFee\n    )\n    console.log(\"Service index when user already owns tokens: \", serviceIndex)\n    return tx.transactionHash\n\n}\n\n// main function executed by the button\nasync function runCompute(dataDid: string, algoDid: string , userAddress: string) {\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const payerAccount = accounts[0]\n\n  const config: any = await getTestConfig(web3)\n  console.log(\"config\", config)\n  const providerUrl = config.providerUri\n\n  const computeEnvs = await ProviderInstance.getComputeEnvironments(providerUrl)\n  console.log(\"Available compute environments\", computeEnvs)\n  const computeEnv = computeEnvs.find((ce) => ce.priceMin === 0)\n  console.log(\"computeEnv\", computeEnv)\n\n  const aquarius = new Aquarius(config.metadataCacheUri)\n  console.log(\"Data DID\", dataDid)\n  console.log(\"Algo DID\", algoDid)\n  const resolvedDdoWith1mTimeout = await aquarius.waitForAqua(dataDid);\n  const resolvedAlgoDdoWith1mTimeout = await aquarius.waitForAqua(algoDid);\n  console.log(\"resolvedDataDDO\", resolvedDdoWith1mTimeout)\n  console.log(\"resolvedAlgoDDO\", resolvedAlgoDdoWith1mTimeout)\n\n  const assets: any[] = [\n    {\n      documentId: resolvedDdoWith1mTimeout.id,\n      serviceId: resolvedDdoWith1mTimeout.services[0].id\n    }\n  ]\n  console.log(\"assets\", assets)\n  const dtAddressArray = [resolvedDdoWith1mTimeout.services[0].datatokenAddress]\n  console.log(\"dtAddressArray\", dtAddressArray)\n  const algo: any = {\n    documentId: resolvedAlgoDdoWith1mTimeout.id,\n    serviceId: resolvedAlgoDdoWith1mTimeout.services[0].id\n  }\n  console.log(\"algo\", algo)\n  const mytime = new Date()\n  const computeMinutes = 20\n  console.log(\"computeMinutes\", computeMinutes)\n  mytime.setMinutes(mytime.getMinutes() + computeMinutes)\n  let computeValidUntil = Math.floor(mytime.getTime() / 1000)\n  console.log(\"computeValidUntil\", computeValidUntil)\n  if (computeEnv !== undefined) {\n  const providerInitializeComputeResults = await ProviderInstance.initializeCompute(\n    assets,\n    algo,\n    computeEnv.id,\n    computeValidUntil,\n    providerUrl,\n    payerAccount\n  )\n  console.log(\"providerInitializeComputeResults\", providerInitializeComputeResults)\n  console.log(\"Handling order for algorithm\")\n  algo.transferTxId = await handleOrder(\n    resolvedAlgoDdoWith1mTimeout,\n    providerInitializeComputeResults.algorithm,\n    resolvedAlgoDdoWith1mTimeout.services[0].datatokenAddress,\n    payerAccount,\n    computeEnv.consumerAddress,\n    0\n  )\n\n  console.log(\"algo.transferTxId\", algo.transferTxId)\n\n  if (providerInitializeComputeResults.datasets !== undefined) {\n  for (let i = 0; i < providerInitializeComputeResults.datasets.length; i++) {\n    console.log(\"Handling order for dataset\")\n    assets[i].transferTxId = await handleOrder(\n      resolvedDdoWith1mTimeout,\n      providerInitializeComputeResults.datasets[i],\n      dtAddressArray[i],\n      payerAccount,\n      computeEnv.consumerAddress,\n      0\n    )\n  }\n  console.log(\"About to start compute\")\n  console.log(\"Provider URL\", providerUrl)\n  const output: ComputeOutput = {\n    publishAlgorithmLog: true,\n    publishOutput: true\n  }\n\n  const computeJobs: any = await ProviderInstance.computeStart(\n      providerUrl,\n      web3,\n      payerAccount,\n      computeEnv.id,\n      assets[0],\n      algo,\n      // undefined,\n      // undefined,\n      // output\n  )\n\n  console.log(\"computeJobs\", computeJobs)\n\n  const freeEnvDatasetTxId = assets[0].transferTxId\n  console.log(\"freeEnvDatasetTxId\", freeEnvDatasetTxId)\n  const freeEnvAlgoTxId = algo.transferTxId\n  console.log(\"freeEnvAlgoTxId\", freeEnvAlgoTxId)\n  const computeJobId = computeJobs[0].jobId\n\n  console.log(\"computeJobId\", computeJobId)\n  return [computeJobId, resolvedDdoWith1mTimeout]\n  }\n\n  }\n\n}\n\nasync function getComputeStatus(computeJobId: any, dataDid: any) {\n  const config: any = await getTestConfig(web3)\n  const aquarius = new Aquarius(config.metadataCacheUri)\n  // const resolvedDdoWith1mTimeout = await aquarius.waitForAqua(dataDid);\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const consumerAccount = accounts[0]\n  const providerUrl = config.providerUri\n  const jobStatus: any = await ProviderInstance.computeStatus(\n    providerUrl,\n    consumerAccount,\n    computeJobId,\n    dataDid// DATASET_DDO.id\n  )\n  // assert(jobStatus, 'Cannot retrieve compute status!')\n  console.log(jobStatus)\n  return jobStatus[0].statusText\n}\n\nasync function getResults(computeJobId: any) {\n  console.log(\"Getting results\")\n  const config: any = await getTestConfig(web3)\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts',\n  });\n  console.log(\"accounts\", accounts)\n  const consumerAccount = accounts[0]\n  const providerUrl = config.providerUri\n  const downloadURL = await ProviderInstance.getComputeResultUrl(\n    providerUrl,\n    web3,\n    consumerAccount,\n    computeJobId,\n    0\n  )\n\n  console.log(`Compute results URL: ${downloadURL}`)\n  return downloadURL\n}\n     \n  /**\n   * This is a React-based component template. The `render()` function is called\n   * automatically when your component should be re-rendered.\n   */\nclass RunCompute extends StreamlitComponentBase<State> {\n  public state = { computeJobId: \"No compute job\", computeStatus: \"No Status\", computeResults: \"No Compute Results\", isFocused: false }\n\n    public render = (): ReactNode => {\n      // Arguments that are passed to the plugin in Python are accessible\n      // via `this.props.args`. Here, we access the \"name\" arg.\n      // Streamlit sends us a theme object via props that we can use to ensure\n      // that our component has visuals that match the active theme in a\n      // streamlit app.\n      const { theme } = this.props\n      const style: React.CSSProperties = {}\n\n      // Maintain compatibility with older versions of Streamlit that don't send\n      // a theme object.\n      if (theme) {\n        // Use the theme object to style our button border. Alternatively, the\n        // theme style is defined in CSS vars.\n        const borderStyling = `0px solid ${\n          this.state.isFocused ? theme.primaryColor : \"gray\"\n        }`\n        style.border = borderStyling\n        style.outline = borderStyling\n        style.backgroundColor = this.props.args[\"color\"] //\"#FF4B4B\"\n        style.color = \"white\"\n        style.borderRadius = \"0.2rem\"\n      }\n      const message = this.props.args[\"message\"]\n      // Show a button and some text.\n      // When the button is clicked, we'll increment our \"numClicks\" state\n      // variable, and send its new value back to Streamlit, where it'll\n      // be available to the Python program.\n      return (\n        <span>\n          <button\n            style={style}\n            onClick={this.onClicked}\n            disabled={this.props.disabled}\n            onFocus={this._onFocus}\n            onBlur={this._onBlur}\n          >\n            {message}\n          </button>\n        </span>\n      )\n    }\n  \n    /** Click handler for our \"Click Me!\" button. */\n    private onClicked = async (): Promise<void> => {\n      if (this.props.args[\"key\"] === \"c2d\") {\n        const transaction: any = await runCompute(this.props.args[\"data_did\"], this.props.args[\"algo_did\"], this.props.args[\"user_address\"])\n        this.setState(\n          () => ({ computeJobId: transaction }),\n          () => Streamlit.setComponentValue(this.state.computeJobId)\n        )\n      } else if (this.props.args[\"key\"] === \"status\") {\n        const status: any = await getComputeStatus(this.props.args[\"job_id\"], this.props.args[\"data_did\"])\n        this.setState(\n            () => ({ computeStatus: status }),\n            () => Streamlit.setComponentValue(this.state.computeStatus)\n        )\n      } else if (this.props.args[\"key\"] === \"results\") {\n        const results: any = await getResults(this.props.args[\"job_id\"])\n        this.setState(\n          () => ({ computeResults: results }),\n          () => Streamlit.setComponentValue(this.state.computeResults)\n      )\n      }\n      // Increment state.numClicks, and pass the new value back to\n      // Streamlit via `Streamlit.setComponentValue`.\n    }\n  \n    /** Focus handler for our \"Click Me!\" button. */\n    private _onFocus = (): void => {\n      this.setState({ isFocused: true })\n    }\n  \n    /** Blur handler for our \"Click Me!\" button. */\n    private _onBlur = (): void => {\n      this.setState({ isFocused: false })\n    }\n  }\n  \n// \"withStreamlitConnection\" is a wrapper function. It bootstraps the\n// connection between your component and the Streamlit app, and handles\n// passing arguments from Python -> Component.\n//\n// You don't need to edit withStreamlitConnection (but you're welcome to!).\nexport default withStreamlitConnection(RunCompute)\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\n// import OceanDataComponent from \"./OceanDataComponent\"\nimport OceanCompute from \"./OceanCompute\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <OceanCompute />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n"],"sourceRoot":""}